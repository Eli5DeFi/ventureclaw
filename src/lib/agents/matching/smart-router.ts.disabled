// Smart Router - AI-powered capital matching across primary + secondary markets
// Routes projects to best capital source (investors, OTC buyers, liquidity pools)

import OpenAI from 'openai';
import type { ProjectProfile, InvestorProfile } from './project-analyzer';
import type { OrderBookSnapshot } from '../../matching/otc-orderbook';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export interface CapitalSource {
  type: 'investor' | 'otc-buyer' | 'liquidity-pool' | 'debt-facility';
  id: string;
  name: string;
  
  // Available capital
  availableCapital: number;
  minAllocation: number;
  maxAllocation: number;
  
  // Terms
  terms: {
    instrument: string; // "equity", "token", "SAFE", "debt"
    pricingBasis: string; // "valuation", "revenue-multiple", "fixed-price"
    expectedReturn: string; // "20% IRR", "3x MOIC", etc.
    timeHorizon: string;
  };
  
  // Speed
  decisionSpeed: string; // "24 hours", "1 week", "4 weeks"
  capitalDeploymentSpeed: string; // "instant", "1 week", "30 days"
  
  // Fit score
  fitScore: number; // 0-100
  
  // Reasoning
  pros: string[];
  cons: string[];
}

export interface RoutingRecommendation {
  projectId: string;
  amountNeeded: number;
  
  // Recommended capital sources (ranked)
  recommendations: CapitalSource[];
  
  // Optimal strategy
  strategy: {
    primary: CapitalSource;
    fallbacks: CapitalSource[];
    blendedApproach?: {
      sources: Array<{
        source: CapitalSource;
        allocation: number;
        reasoning: string;
      }>;
    };
  };
  
  // Execution plan
  executionPlan: {
    step: number;
    action: string;
    timeline: string;
    expectedOutcome: string;
  }[];
  
  // Risk analysis
  risks: {
    risk: string;
    probability: 'high' | 'medium' | 'low';
    mitigation: string;
  }[];
  
  // Market conditions
  marketConditions: {
    sentiment: 'bullish' | 'neutral' | 'bearish';
    competitionLevel: 'high' | 'medium' | 'low';
    fundingAvailability: 'abundant' | 'moderate' | 'scarce';
    recommendation: string;
  };
}

export async function routeCapital(
  project: ProjectProfile,
  investors: InvestorProfile[],
  otcSnapshots: OrderBookSnapshot[]
): Promise<RoutingRecommendation> {
  // Analyze all available capital sources
  const capitalSources: CapitalSource[] = [];
  
  // 1. Traditional investors (VCs, angels)
  for (const investor of investors) {
    capitalSources.push({
      type: 'investor',
      id: investor.id,
      name: investor.name,
      availableCapital: investor.checkSize.max,
      minAllocation: investor.checkSize.min,
      maxAllocation: investor.checkSize.max,
      terms: {
        instrument: 'equity',
        pricingBasis: 'valuation',
        expectedReturn: '10x MOIC over 7 years',
        timeHorizon: '5-7 years',
      },
      decisionSpeed: investor.type === 'angel' ? '1 week' : '4 weeks',
      capitalDeploymentSpeed: '30 days',
      fitScore: 0, // Will be calculated below
      pros: [],
      cons: [],
    });
  }
  
  // 2. OTC buyers (for secondary shares/tokens)
  for (const snapshot of otcSnapshots) {
    if (snapshot.bids.length > 0) {
      const topBid = snapshot.bids[0];
      capitalSources.push({
        type: 'otc-buyer',
        id: snapshot.assetId,
        name: `OTC Market (${snapshot.assetId})`,
        availableCapital: topBid.quantity * topBid.price,
        minAllocation: topBid.price, // 1 share
        maxAllocation: topBid.quantity * topBid.price,
        terms: {
          instrument: 'secondary-shares',
          pricingBasis: 'market-price',
          expectedReturn: 'Market-driven',
          timeHorizon: 'Immediate liquidity',
        },
        decisionSpeed: 'instant',
        capitalDeploymentSpeed: 'instant',
        fitScore: 0,
        pros: ['Instant liquidity', 'Market-driven pricing', 'No dilution'],
        cons: ['Limited size', 'Volatile pricing', 'Selling existing shares'],
      });
    }
  }
  
  // 3. AI-powered routing decision
  const prompt = `You are a capital markets AI router analyzing optimal funding sources.

Project Seeking Capital:
- Name: ${project.name}
- Industry: ${project.industry}
- Stage: ${project.stage}
- Amount Needed: $${project.amountSeeking.toLocaleString()}
- Revenue: $${project.revenue.toLocaleString()}
- Growth: ${project.revenueGrowth}%
- Funding Type: ${project.fundingType}

Available Capital Sources (${capitalSources.length}):
${capitalSources
  .map(
    (s, i) =>
      `${i + 1}. ${s.type.toUpperCase()}: ${s.name}
   - Available: $${s.availableCapital.toLocaleString()}
   - Terms: ${s.terms.instrument}, ${s.terms.expectedReturn}
   - Speed: ${s.decisionSpeed} decision, ${s.capitalDeploymentSpeed} deployment`
  )
  .join('\n')}

Task: Recommend optimal capital routing strategy:

1. **Score Each Source** (0-100)
   - Size fit (can they deploy needed capital?)
   - Speed fit (does timeline match project needs?)
   - Terms fit (are terms acceptable?)
   - Strategic value (beyond capital - mentorship, network, etc.)

2. **Rank Sources** (best to worst)

3. **Determine Strategy**:
   - **Single Source:** If one investor can do full round
   - **Blended:** If multiple sources needed (e.g., 60% VC + 40% OTC)
   - **Sequential:** If waterfall approach (try A, if fails try B)

4. **Execution Plan** (step-by-step):
   - Step 1: Action, timeline, expected outcome
   - Step 2: ...
   - Step 3: ...

5. **Market Conditions Assessment**:
   - Current funding sentiment (bullish/neutral/bearish)
   - Competition for deals in this space
   - Funding availability
   - Timing recommendation (now vs wait)

6. **Risks & Mitigation**:
   - Deal falling through
   - Terms worse than expected
   - Timing delays
   - Market downturn

Return JSON with routing recommendation.`;

  const completion = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'system',
        content:
          'You are a capital markets routing AI. Optimize for speed, price, and strategic fit.',
      },
      { role: 'user', content: prompt },
    ],
    temperature: 0.3,
    response_format: { type: 'json_object' },
  });

  const analysis = JSON.parse(completion.choices[0].message.content || '{}');

  // Build recommendation
  const recommendation: RoutingRecommendation = {
    projectId: project.id,
    amountNeeded: project.amountSeeking,
    recommendations: analysis.rankedSources || capitalSources,
    strategy: analysis.strategy || {
      primary: capitalSources[0],
      fallbacks: capitalSources.slice(1, 3),
    },
    executionPlan: analysis.executionPlan || [],
    risks: analysis.risks || [],
    marketConditions: analysis.marketConditions || {
      sentiment: 'neutral',
      competitionLevel: 'medium',
      fundingAvailability: 'moderate',
      recommendation: 'Proceed with caution',
    },
  };

  return recommendation;
}

// Price discovery: what's fair valuation based on comparables + market?
export async function discoverPrice(
  project: ProjectProfile,
  comparables: Array<{
    company: string;
    revenue: number;
    valuation: number;
    multiple: number;
  }>
): Promise<{
  suggestedValuation: { low: number; base: number; high: number };
  methodology: string;
  comparableMedian: number;
  adjustment: string;
}> {
  const prompt = `You are a valuation analyst determining fair market value.

Project:
- Industry: ${project.industry}
- Stage: ${project.stage}
- Revenue: $${project.revenue.toLocaleString()}
- Growth: ${project.revenueGrowth}%

Comparables:
${comparables.map((c) => `- ${c.company}: $${c.revenue.toLocaleString()} revenue â†’ $${c.valuation.toLocaleString()} valuation (${c.multiple}x)`).join('\n')}

Task: Determine fair valuation range:

1. Calculate median comparable multiple
2. Adjust for:
   - Growth rate (higher growth = premium)
   - Stage (earlier = discount)
   - Market conditions
   - Competitive position
3. Provide low/base/high range
4. Explain methodology

Return JSON.`;

  const completion = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: 'You are a valuation analyst.' },
      { role: 'user', content: prompt },
    ],
    temperature: 0.2,
    response_format: { type: 'json_object' },
  });

  const result = JSON.parse(completion.choices[0].message.content || '{}');

  return {
    suggestedValuation: result.suggestedValuation || { low: 0, base: 0, high: 0 },
    methodology: result.methodology || '',
    comparableMedian: result.comparableMedian || 0,
    adjustment: result.adjustment || '',
  };
}

// Liquidity analysis: OTC vs primary fundraising
export function analyzeLiquidityOptions(
  amountNeeded: number,
  otcSnapshot: OrderBookSnapshot
): {
  otcViable: boolean;
  otcAvailableCapital: number;
  otcAveragePrice: number;
  otcSlippage: number;
  recommendation: string;
} {
  // Calculate how much capital available via OTC
  let otcAvailableCapital = 0;
  let totalQuantity = 0;
  
  for (const bid of otcSnapshot.bids) {
    otcAvailableCapital += bid.price * bid.quantity;
    totalQuantity += bid.quantity;
  }
  
  const otcAveragePrice = totalQuantity > 0 ? otcAvailableCapital / totalQuantity : 0;
  
  // Estimate slippage if trying to fill $amountNeeded
  const otcSlippage = calculateSlippage(amountNeeded, otcSnapshot.bids);
  
  const otcViable = otcAvailableCapital >= amountNeeded * 0.8; // 80% threshold
  
  const recommendation = otcViable
    ? `OTC market can provide $${otcAvailableCapital.toLocaleString()} (${((otcAvailableCapital / amountNeeded) * 100).toFixed(0)}% of needed capital). Consider blended approach: partial OTC fill + investor top-up.`
    : `OTC market insufficient ($${otcAvailableCapital.toLocaleString()} available vs $${amountNeeded.toLocaleString()} needed). Focus on primary fundraising.`;
  
  return {
    otcViable,
    otcAvailableCapital,
    otcAveragePrice,
    otcSlippage,
    recommendation,
  };
}

// Helper: Calculate slippage for large order
function calculateSlippage(amountNeeded: number, bids: Array<{ price: number; quantity: number }>): number {
  let remainingAmount = amountNeeded;
  let totalCost = 0;
  let totalQuantity = 0;
  
  for (const bid of bids) {
    if (remainingAmount <= 0) break;
    
    const canFill = Math.min(remainingAmount / bid.price, bid.quantity);
    totalCost += canFill * bid.price;
    totalQuantity += canFill;
    remainingAmount -= canFill * bid.price;
  }
  
  if (totalQuantity === 0) return 0;
  
  const averagePrice = totalCost / totalQuantity;
  const bestPrice = bids[0]?.price || 0;
  
  return bestPrice > 0 ? ((averagePrice - bestPrice) / bestPrice) * 100 : 0;
}
